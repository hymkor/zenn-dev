---
title: "コマンド出力の引用"
free: false
---

逆クォートそのまんまの互換文法はありませんが、1行ごとに引用ならば、bash で書くところの

```bash
ls | while read line ; do echo ">>$line" ; done
```

に対応する処理をバッチファイルでは

```batch
for /F "tokens=*" %%I in ('dir') do echo ^>^> %%I
```

と書けます。**丸括弧の内側にシングルクォートがあることに注意しましょう**

* 通常 for /F では各行を空白/タブで分割して処理しますが、`"tokens=*"` というオプションをつけると、全フィールドを１変数にまとめます(awkの$0相当)。逆に `"tokens=*"` を省略して、いきなり `for /F %%I…` と書くと、最初のフィールドだけが `%%I` に格納されます（awkの$1相当）
* 分割されたフィールドを別々の変数に格納する場合は `for /F "tokens=1,2,3" %%I in ('dir') do …` などとします。すると、最初のフィールドは `%%I` , 2番目のフィールドが `%%J` , 3番目は `%%K` などと次のアルファベットの変数名が順に使われます（**なんちゅう仕様だ**）
* バッチファイルにおいて、機能文字を無効化するエスケープ文字は `^`（キャレット）です。echo で二重引用符を使うと、二重引用符自体が表示されてしまうので、リダイレクト文字を `^` で無効化しています。

for は無駄に高機能で、区切り文字を指定したり、頑張れば AWK に近いことも出来ます。「for /?」で詳しい使い方を見ると、かなりできる幅が広がるでしょう。

余談ですが
====

UNIX ではコマンドのパラメータは文字列配列(argv[])ですが、DOS/Windows ではコマンドラインの引数全部がそのまま１文字列の形で引き渡されます。そのため引用符の種類すらもコマンド側で検知できてしまいます。結果、コマンドが引用符の有無でパラメータの位置づけを判断するということも普通にあったりします。
- for コマンド：二重引用符で囲まれた部分をオプションとして扱う
- echo コマンド：二重引用符もそのまま出力する
- find コマンド：検索文字列は二重引用符で囲まれていなければいけない。
- start コマンド：第一引数が二重引用符で囲まれていたら、コマンド名ではなく、ウインドウタイトルとみなす

便利なようで難儀なケースの方が多いですね。